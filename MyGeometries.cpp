//
//  MyGeometries.cpp
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #4.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include "GL/glew.h" 
#include "GLFW/glfw3.h"

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "ShaderBuild.h"

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 16;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "BrickWallTexture.bmp",
    "KalachakraSera.bmp",
    "RoughWood.bmp",
    "earth_clouds.bmp",
	"space.bmp",
	"marble-background.bmp",
	"jupitermap.bmp",
	"lion.bmp", 
	"ocean.bmp",
	"soccerfield.bmp",
	"soccerfans.bmp",
	"soccerball.bmp",
	"grass.bmp",
	"barcelona.bmp",
	"manu.bmp",
	"sidestadium.bmp"
};

// *******************************
// Two spheres and a cylinder
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);

// Will be used to render the goal posts of the goals
// post1= left side post2 = top  post3 = right side
GlGeomCylinder post1A;
GlGeomCylinder post1B;
GlGeomCylinder post2A;
GlGeomCylinder post2B;
GlGeomCylinder post3A;
GlGeomCylinder post3B;


// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 5;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;            // RESERVED FOR USE BY 155A PROJECT
const int iPlayers = 3;
const int itriFlag1 = 4;
bool flagVerticalDirection = true;								// Flag will be used to know if we are moving upwards or downwards
bool flagHorizontalDirection = true;							// Flag will be used to know if we are moving left or right
double ballHeight = 0.02;						// Used to control the height of the ball moving animation
double ballWidth = 0.2;
double MAX_HEIGHT = 2.0;
double MAX_WIDTH = 5.0;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IY YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE TO DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.2);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // Load texture maps
    RgbImage texMap;

    glUseProgram(phShaderPhongPhong);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the phShaderPhongPhong uses the GL_TEXTURE_0 texture.
    glUseProgram(phShaderPhongPhong);
    glUniform1i(glGetUniformLocation(phShaderPhongPhong, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

	// Initialize the cyclinders and give them their location location
	post1A.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
	post1B.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
	post2A.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
	post2B.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
	post3A.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
	post3B.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Back Wall:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE BACK WALL
    float wallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -7.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left
         7.0f, 5.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
         7.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
        -7.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
    };
    unsigned int wallElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts) * sizeof(unsigned int), wallElts, GL_STATIC_DRAW);

	// Set up the space to place the players
	float playerVerts[] = {
		// Position              // Normal                  // Texture coordinates
		-1.2f, 0.8f, -3.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left
		1.2f, 0.8f, -3.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
		1.2f, 0.0f, -3.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
		-1.2f, 0.0f, -3.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
	};
	unsigned int playerElts[] = { 0, 3, 1, 2 };
	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iPlayers]);
	glBindVertexArray(myVAO[iPlayers]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(playerVerts), playerVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iPlayers]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(playerElts) * sizeof(unsigned int), playerElts, GL_STATIC_DRAW);

	// Set up the space to place the corner flags
	float flagVerts[] = {
		// Position							// Normals					// Texture Coordinates
		0.0f, 0.1f, 0.0f,					0.0f, 0.0f, 1.0f,			0.0f, 1.0f,			// Top left
		0.1f, 0.1f, 0.0f,					0.0f, 0.0f, 1.0f,			1.0f, 1.0f,			// Top right
		0.1f, 0.0f, 0.0f,					10.0f, 0.0f, 1.0f,			1.0f, 0.0f,			// Bottom right
		0.0f, 0.0f, 0.0f,					10.0f, 0.0f, 1.0f,			0.0f, 0.0f,			// Bottom left
	};
	unsigned int flagElts[] = { 0, 3, 1, 2 };
	glBindBuffer(GL_ARRAY_BUFFER, myVBO[itriFlag1]);
	glBindVertexArray(myVAO[itriFlag1]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(flagVerts), flagVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[itriFlag1]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(flagElts) * sizeof(unsigned int), flagElts, GL_STATIC_DRAW);

    // For the circular surface:
    // Allocate the needed VAO, VBO< EBO
    // The normal vectors is specified separately for each vertex. (It is not a generic attribute.)
    // YOU MUST MODIFY THIS TO (A) USE STRIDES OF 8 *sizeof(float), (B) COMMENT IN THE LINES FOR vertTexCoords 
    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	// Store vertices in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); // Store normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                 // Enabled the stored normals (so they are not generic)
    // ONCE YOU HAVE TEXTURE COORDINATES WORKING FOR THE CIRCULAR SURFACE,
    //   PUT THE NEXT TWO LINES BACK IN, AND CHANGE THE STRIDE TO "8" IN THE PREVIOUS CALLS TO glVertexAttribPointer.
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices

    // No data has been loaded into the VBO's for the circular surface yet.
    // This is done by the "SamsRemeshCircularSurf" routine.

    SamsRemeshCircularSurf();

    // FOR THE FLOOR: ADD YOUR OWN CODE!! 
    // IT WILL BE SIMILAR TO THE BACK WALL ABOVE.
    // YOU DO NOT NEED TO REMESH THE FLOOR - ONE RECTANGLE IS ENOUGH
	float floorVerts[] = {
		// Position              // Normal                  // Texture coordinates
		-5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Far left
		5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Far right
		5.0f, 0.0f, 5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Near right
		-5.0f, 0.0f, 5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Near left
	};
	unsigned int floorElts[] = { 0, 3, 1, 2 };
	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
	glBindVertexArray(myVAO[iFloor]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts) * sizeof(unsigned int), floorElts, GL_STATIC_DRAW);

	viewMatrix.SetIdentity();
    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    SamsRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);

	post1A.Remesh(meshRes, meshRes, meshRes);
	post1B.Remesh(meshRes, meshRes, meshRes);
	post2A.Remesh(meshRes, meshRes, meshRes);
	post2B.Remesh(meshRes, meshRes, meshRes);
	post3A.Remesh(meshRes, meshRes, meshRes);
	post3B.Remesh(meshRes, meshRes, meshRes);

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO CALL YOUR OWN CODE IN
//    TO RENDER THE FLOOR AND THE SPHERES AND 
//    THE CYLINDER.
// **********************************************

void MyRenderGeometries() {
    // ******
    // Render the Back Wall
    // ******
	LinearMapR4 matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0f, -0.02f, 0.0f);
    glBindVertexArray(myVAO[iWall]);                // Select the back wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Brick wall texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the wall as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);    
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

	// Render the nearest wall
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0f, -0.02f, 1.2f);
	matDemo.Mult_glRotate(3.14, 0.0, 1.0, 0.0);
	//matDemo.DumpByColumns(matEntries);
	glBindVertexArray(myVAO[iWall]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

	// Render the left wall
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-2.0f, -0.02f, 0.6f);
	matDemo.Mult_glRotate(1.57, 0.0, 1.0, 0.0);
	matDemo.Mult_glScale(0.8f, 1.0f, 1.0f);
	//matDemo.DumpByColumns(matEntries);
	glBindVertexArray(myVAO[iWall]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

	// Render the right wall
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(2.0f, -0.02f, 0.6f);
	matDemo.Mult_glRotate(-1.57, 0.0, 1.0, 0.0);
	matDemo.Mult_glScale(0.8f, 1.0f, 1.0f);
	//matDemo.DumpByColumns(matEntries);
	glBindVertexArray(myVAO[iWall]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Brick wall texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
													   // Draw the wall as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    // **************
    // Render the circular surface
    /*SamsRenderCircularSurf();*/

    // ************ 
    // Render the floor
    //  YOU MUST WRITE THIS. IT WILL BE SIMILAR TO THE BACK WALL ABOVE
	matDemo = viewMatrix;
	glBindVertexArray(myVAO[iFloor]);				// Select the floor Vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	viewMatrix.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[9]);	// Choose the soccer field texture
	glUniform1i(applyTextureLocation, true);		// Enable applying the texture
	// Draw the floor as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying texture
	
	// Render the grass surrounding the soccer stadium
	matDemo = viewMatrix;
	matDemo.Mult_glScale(2.0f, 1.0, 2.0f);
	matDemo.Mult_glTranslate(0.0f, -0.02f, 0.0f);

	glBindVertexArray(myVAO[iFloor]);				// Select the floor Vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[12]);	// Choose the grass
	glUniform1i(applyTextureLocation, true);		// Enable applying the texture
	// Draw the floor as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying texture

	// Render the players
	/*
	glBindVertexArray(myVAO[iPlayers]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	viewMatrix.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[13]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture
	*/


    // Render a soccer ball
	matDemo = viewMatrix;
    matDemo.Mult_glTranslate(ballWidth, ballHeight, 0.0);
	matDemo.Mult_glScale(.1, .1, .1);
	matDemo.Mult_glRotate(1.57, 0.0, 0.0, 1.0);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose soccer image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
	// Check if we need to change the direction of our ball (vertically)
	if (ballHeight > MAX_HEIGHT) {
		flagVerticalDirection = false;
		ballHeight = MAX_HEIGHT;
	}
	else if (ballHeight < 0.0) {
		flagVerticalDirection = true;
		ballHeight = 0.02;
	}
	else {
		if (flagVerticalDirection) {
			ballHeight += animateIncrement;
		}
		else {
			ballHeight -= animateIncrement;
		}
	}
	// Check if we need to change the direction of our ball (horizontally)
	if (ballWidth > MAX_WIDTH) {
		flagHorizontalDirection = false;
		ballWidth = MAX_WIDTH;
	}
	else if (ballWidth < -MAX_WIDTH) {
		flagHorizontalDirection = true;
		ballWidth = -MAX_WIDTH;
	}
	else {
		if (flagHorizontalDirection) {
			ballWidth += animateIncrement;
		}
		else {
			ballWidth -= animateIncrement;
		}
	}

	// Render a sphere with a jupiter image texture map
    // ADD A TEXTURE MAP TO THIS SPHERE - SIMILAR TO THE CODE ABOVE
    /*matDemo = viewMatrix;
    matDemo.Mult_glTranslate( 3.5, 1.1, 0.4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[6]);
	glUniform1i(applyTextureLocation, true);
    texSphere.Render();                                 // Render the sphere
	glUniform1i(applyTextureLocation, false);*/

    // Render a cylinder 
    // YOU MAY LEAVE THE TEXTURE MAP ON THE SIDE OF THE CYLINDER
    // YOU MUST ADD TEXTURE MAPS TO THE TOP AND BOTTOM FACES OF THE CYLINDER
    /*matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 1.1, 1.0);
	matDemo.Mult_glRotate(1.57, 0.0, 0.0, 1.0);
	matDemo.Mult_glScale(0.7, 1.0, 0.7);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose wood image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
	// Apply Texture map for the top
	glBindTexture(GL_TEXTURE_2D, TextureNames[1]);
	glUniform1i(applyTextureLocation, true);
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
	glUniform1i(applyTextureLocation, false);
	// Apply Texture map for the base
	glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
	glUniform1i(applyTextureLocation, true);
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
	glUniform1i(applyTextureLocation, false);*/

	// Render the left front post of the first goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.65, 0.29, 1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the left back post
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.8, 0.29, 1.0);
	matDemo.Mult_glRotate(-.6, 0.0, 0.0, 1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the top bar of the first goal post
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.65, 0.55, 0.0);
	matDemo.Mult_glRotate(1.57, 1.0, 0.0, 0.0);
	matDemo.Mult_glScale(.05, 1.05, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post2A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the bottom bar of the first goal post
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.95, 0.05, 0.0);
	matDemo.Mult_glRotate(1.57, 1.0, 0.0, 0.0);
	matDemo.Mult_glScale(.05, 1.05, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post2A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the right front post of the first goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.65, 0.29, -1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post3A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the right back post of the first goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.8, 0.29, -1.0);
	matDemo.Mult_glRotate(-.6, 0.0, 0.0, 1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false

	/* Render the second goal post (on the right side of the screen)*/

	// Render the left front post of the second goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.65, 0.29, 1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the left back post of the second goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.8, 0.29, 1.0);
	matDemo.Mult_glRotate(.6, 0.0, 0.0, 1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the top bar of the second goal post
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.65, 0.55, 0.0);
	matDemo.Mult_glRotate(1.57, 1.0, 0.0, 0.0);
	matDemo.Mult_glScale(.05, 1.05, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post2A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the bottom bar of the second goal post
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.95, 0.05, 0.0);
	matDemo.Mult_glRotate(1.57, 1.0, 0.0, 0.0);
	matDemo.Mult_glScale(.05, 1.05, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post2A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the right front post of the second goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.65, 0.29, -1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post3A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the right back post of the second goal
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.8, 0.29, -1.0);
	matDemo.Mult_glRotate(.6, 0.0, 0.0, 1.0);
	matDemo.Mult_glScale(.05, .28, .05);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	/* Render the flags on the corners*/

	// Render far left flag
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.57, 0.1, -4.64);
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Back part of the far left flag
	matDemo = viewMatrix;
	// Add 0.1 to the regular x translation to take into account the movement it makes when rotated 180 degrees
	matDemo.Mult_glTranslate(-4.47, 0.1, -4.64);
	matDemo.Mult_glRotate(3.14, 0.0f, 1.0f, 0.0f);
	//matDemo.Mult_glTranslate(0.1f, 0.0f, 0.0f);			// Takes into count the movement when we rotate the flag
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Render the pole for the flag on the far left corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.57, 0.1, -4.64);
	matDemo.Mult_glScale(.01, .1, .01);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the flag on the far right corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.57, 0.1, -4.64);
	glBindVertexArray(myVAO[itriFlag1]);				// Select the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Back part of flag on far right corner
	matDemo = viewMatrix;
	// Add 0.1 to the regular x translation to take into account the movement it makes when rotated 180 degrees
	matDemo.Mult_glTranslate(4.67, 0.1, -4.64);
	matDemo.Mult_glRotate(3.14, 0.0f, 1.0f, 0.0f);
	//matDemo.Mult_glTranslate(0.1f, 0.0f, 0.0f);			// Takes into count the movement when we rotate the flag
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Render the flag pole on the far right corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.57, 0.1, -4.64);
	matDemo.Mult_glScale(.01, .1, .01);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the flag on the near right corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.57, 0.1, 4.64);
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Back part of the flag on the near right corner
	matDemo = viewMatrix;
	// Add 0.1 to the regular x translation to take into account the movement it makes when rotated 180 degrees
	matDemo.Mult_glTranslate(4.67, 0.1, 4.64);
	matDemo.Mult_glRotate(3.14, 0.0f, 1.0f, 0.0f);
	//matDemo.Mult_glTranslate(0.1f, 0.0f, 0.0f);			// Takes into count the movement when we rotate the flag
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Render the flag pole on the near right corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(4.57, 0.1, 4.64);
	matDemo.Mult_glScale(.01, .1, .01);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

	// Render the flag on the near left corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.57, 0.1, 4.64);
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Back part of the flag on near left corner
	matDemo = viewMatrix;
	// Add 0.1 to the regular x translation to take into account the movement it makes when rotated 180 degrees
	matDemo.Mult_glTranslate(-4.47, 0.1, 4.64);
	matDemo.Mult_glRotate(3.14, 0.0f, 1.0f, 0.0f);
	//matDemo.Mult_glTranslate(0.1f, 0.0f, 0.0f);			// Takes into count the movement when we rotate the flag
	glBindVertexArray(myVAO[itriFlag1]);				// Selecte the players vertex object array
	materialUnderTexture.LoadIntoShaders();			// Use the bright underlying colors
	matDemo.DumpByColumns(matEntries);			// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[14]);
	glUniform1i(applyTextureLocation, true);
	// Draw the grid as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	glUniform1i(applyTextureLocation, false);		// Turn off applying the texture

	// Render the flag pole on the near left corner
	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(-4.57, 0.1, 4.64);
	matDemo.Mult_glScale(.01, .1, .01);
	matDemo.DumpByColumns(matEntries);						// Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	//glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
	//glUniform1i(applyTextureLocation, true);
	post1A.Render();
	//glUniform1i(applyTextureLocation, false);

    check_for_opengl_errors();      // Watch the console window for error messages!
}

void SamsRenderCircularSurf()
{
    glBindVertexArray(myVAO[iCircularSurf]);

    // Calculate the model view matrix for the circular surface
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 0.75, -2.5);     // Center in the back & raise up
    matDemo.Mult_glScale(0.15, 2.0, 0.15);         // Adjust the circular diameter and height

                                                 // Set the uniform values (they are not stored with the VAO and thus must be set again everytime
    materialUnderTexture.LoadIntoShaders();                       // Use the bright underlying material
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries); // Select the modelview matrix to place it
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose Mandala texture
    // ONCE YOU HAVE TEXTURE COORDINATES FOR THE CIRCULAR SURFACE, PUT THE NEXT LINE BACK IN.
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                                                                   // Draw the the triangle strips
    for (int i = 0; i < meshRes; i++) {
        glDrawElements(GL_TRIANGLE_STRIP, 1 + 2 * meshRes, GL_UNSIGNED_INT,
            (void*)(i * (1 + 2 * meshRes) * sizeof(unsigned int)));
    }
    glUniform1i(applyTextureLocation, false);           // Disable applying the texture!
}


// *******
// ADD TEXTURE COORDINATES TO EITHER YOUR OWN "MyRemeshCircularSurf" or
// TO THE PROVIDED "SamsRemeshCircularSurf"
// IF YOU USE YOUR OWN, ALSO REPLACE "SamsRenderCircularMesh" WITH YOUR
// OWN "MyRenderCircularMesh" IF NEEDED.
// TASKS FOR ADDING TEXTURE COORDINATES:
//    a. Change stride to 8*sizeof(float) instead 6*sizeof(float).
//    b. Be sure to allocate enough memory for circularVerts[].
//    c. Calculate the (s,t) texture coordinates, put them in the array.
//    d. Update the calls to glVertexAttribPointer and glEnableVertexAttribArray
//         in the routine MySetupSurfaces above.

void SamsRemeshCircularSurf()
{

    // Circular surface vertices.
    int numCircularVerts = 1 + meshRes * meshRes;
    float* circularVerts = new float[8 * numCircularVerts];
    // Circular surface elements (indices to vertices in a triangle strip)
    int numCircularElts = meshRes * (1 + 2 * meshRes);
    unsigned int* circularElements = new unsigned int[numCircularElts];

    float* toPtr = circularVerts;
    *(toPtr++) = 0.0f;      // Center point
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.0f;      // Center normal
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
	// Add Texture Coordinates
	*(toPtr++) = 0.5f;
	*(toPtr++) = 0.5f;
	// Calculate the stepsize
	float circleLength = 0.6;
	float stepsize = meshRes/circleLength;
    for (int i = 0; i < meshRes; i++) {
        float theta = (float)PI2 * ((float)i) / (float)meshRes;
        float c = cosf(theta);
        float s = sinf(theta);

        for (int j = 1; j <= meshRes; j++) {
            float r = 5.0f * (float)PI * ((float)j) / (float)meshRes;
            float rprime = (r * cosf(r) - sinf(r)) / (r*r);
            float norm = sqrtf(1.0f + rprime * rprime);
            *(toPtr++) = c * r;                 // (i,j) point
            *(toPtr++) = sinf(r) / r;
            *(toPtr++) = s * r;
            *(toPtr++) = -c * rprime / norm;      // (i,j) normal
            *(toPtr++) = 1.0f / norm;
            *(toPtr++) = -s * rprime / norm;
			// Add texture coordinates
			*(toPtr++) = 0.5 + (r/(5*PI)) * .4243 * cos(theta);
			*(toPtr++) = 0.5 + (r/(5*PI)) * .4243 * sin(theta);


        }
    }

    unsigned int* toElt = circularElements;
    for (int i = 0; i < meshRes; i++) {
        *(toElt++) = 0;         // Central vertex
        for (int j = 0; j < meshRes; j++) {
            *(toElt++) = ((i + 1) % meshRes) * meshRes + j + 1;
            *(toElt++) = i * meshRes + j + 1;
        }
    }

    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBufferData(GL_ARRAY_BUFFER, 8 * numCircularVerts * sizeof(float), circularVerts, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numCircularElts * sizeof(unsigned int), circularElements, GL_STATIC_DRAW);

    delete[] circularVerts;
    delete[] circularElements;
}

